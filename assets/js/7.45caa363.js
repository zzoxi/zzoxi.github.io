(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{333:function(a,t,_){"use strict";_.r(t);var s=_(4),r=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"innodb引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#innodb引擎"}},[a._v("#")]),a._v(" InnoDB引擎")]),a._v(" "),t("h2",{attrs:{id:"第一章-mysql简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第一章-mysql简介"}},[a._v("#")]),a._v(" 第一章 MySQL简介")]),a._v(" "),t("h3",{attrs:{id:"_1-1-mysql体系结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-mysql体系结构"}},[a._v("#")]),a._v(" 1.1 MySQL体系结构")]),a._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("我的提示")]),a._v(" "),t("p",[a._v("这是一条提示")])]),a._v(" "),t("p",[a._v("MySQL由以下几部分组成\n连接池、管理服务和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲组件、插件式存储引擎、物理文件。\nMySQL区别于其他数据库的最重要的一个特点是插件式的表存储引擎。")]),a._v(" "),t("h3",{attrs:{id:"_1-2-mysql存储引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-mysql存储引擎"}},[a._v("#")]),a._v(" 1.2 MySQL存储引擎")]),a._v(" "),t("h4",{attrs:{id:"innodb与myisam区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#innodb与myisam区别"}},[a._v("#")]),a._v(" InnoDB与MyISAM区别")]),a._v(" "),t("p",[a._v("InnoDB支持事务，特点是行锁设计、支持外键。使用MVCC获得高并发，实现了标准4种隔离级别。\nMyISAM不支持事务，表锁设计，支持全文索引。缓冲池只缓存索引文件，而不缓冲数据文件。")]),a._v(" "),t("h2",{attrs:{id:"第二章-innodb存储引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第二章-innodb存储引擎"}},[a._v("#")]),a._v(" 第二章 InnoDB存储引擎")]),a._v(" "),t("h3",{attrs:{id:"_1-1-概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-概述"}},[a._v("#")]),a._v(" 1.1 概述")]),a._v(" "),t("p",[a._v("特点：行锁设计、支持MVCC、支持外键、提供一致性非锁定读（？）")]),a._v(" "),t("h3",{attrs:{id:"_2-3-innodb体系架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-innodb体系架构"}},[a._v("#")]),a._v(" 2.3 InnoDB体系架构")]),a._v(" "),t("p",[a._v("主要是后台线程与内存池")]),a._v(" "),t("h4",{attrs:{id:"后台线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后台线程"}},[a._v("#")]),a._v(" 后台线程")]),a._v(" "),t("p",[a._v("1、Master Thread\n2、IO Thread\nInnoDB中大量使用了AIO来处理IO请求，极大提高数据库的性能。\n3、Purge Thread")]),a._v(" "),t("h4",{attrs:{id:"内存池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存池"}},[a._v("#")]),a._v(" 内存池")]),a._v(" "),t("p",[a._v("1、缓冲池\n2、LRU\n缓冲池是通过LRU（最近最少使用）算法来管理，最频繁使用的页在LRU列表的前端，最少使用的页在LRU列表后端。\nInnoDB对传统的LRU算法做了一些优化，LRU列表中加入了midpoint位置。新读取到的页放进midpoint位置。\n为什么要这样做？\n一些操作如索引或数据扫描操作，需要访问表中许多页，甚至全部页。如果放在首部，非常可能将热点数据也从列表中顶掉移除。\n引入了一个参数innodb_old_blocks_time 表示页读取到mid位置后等待多久才会被加入到LRU的热端，设置为0避免热点数据刷出")]),a._v(" "),t("p",[a._v("数据库刚启动时，LRU列表为空，这些页都存放在Free列表中，当需要从缓冲池中分页时，首先从Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表。\nLRU列表的old部分加入到new部分时，此时的操作叫 page made young。")]),a._v(" "),t("p",[a._v("3、重做日志缓冲")]),a._v(" "),t("h2",{attrs:{id:"文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文件"}},[a._v("#")]),a._v(" 文件")]),a._v(" "),t("h3",{attrs:{id:"_3-1-参数文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-参数文件"}},[a._v("#")]),a._v(" 3.1 参数文件")]),a._v(" "),t("h3",{attrs:{id:"_3-2-日志文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-日志文件"}},[a._v("#")]),a._v(" 3.2 日志文件")]),a._v(" "),t("p",[a._v("常见的日志文件主要有错误日志、二进制日志（binlog）、慢查询日志（slow query log）")]),a._v(" "),t("h2",{attrs:{id:"第四章-表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第四章-表"}},[a._v("#")]),a._v(" 第四章 表")]),a._v(" "),t("h3",{attrs:{id:"_4-1-索引组织表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-索引组织表"}},[a._v("#")]),a._v(" 4.1 索引组织表")]),a._v(" "),t("p",[a._v("InnoDB引擎中，表都是按照主键顺序组织存放的，这种存储方式的表称为索引组织表。\n如果创建表时没有显示定义主键，InnoDB会首先判断是否有非空的唯一索引，如果有，则该列为主键。如不存在，InnoDB引擎自动创建一个6字节大小的指针。")]),a._v(" "),t("h3",{attrs:{id:"_4-2-innodb逻辑存储结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-innodb逻辑存储结构"}},[a._v("#")]),a._v(" 4.2 InnoDB逻辑存储结构")]),a._v(" "),t("p",[a._v("所有数据都被逻辑地存放在一个空间中，称为表空间。表空间又由段、区、页组成。")]),a._v(" "),t("h4",{attrs:{id:"_4-2-1-表空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-1-表空间"}},[a._v("#")]),a._v(" 4.2.1 表空间")]),a._v(" "),t("p",[a._v("默认情况下InnoDB存储引擎有一个共享表空间ibdata1，用户可以启用参数innodb_file_per_table,每张表内的数据单独放到一个表空间。")]),a._v(" "),t("h4",{attrs:{id:"_4-2-2-段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-2-段"}},[a._v("#")]),a._v(" 4.2.2 段")]),a._v(" "),t("p",[a._v("常见的段有数据段、索引段、回滚段。\n数据即索引，索引及数据。数据段为B+树的叶子节点，索引段为B+树的非索引节点。")]),a._v(" "),t("h4",{attrs:{id:"_4-2-3-区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-3-区"}},[a._v("#")]),a._v(" 4.2.3 区")]),a._v(" "),t("p",[a._v("区时连续页组成的空间，InnoDB页默认16KB、一个区大小为1MB，一个区中一共有64个连续的页\nInnoDB 1.0.x后裔i纳入压缩页，页的大小可以为2K、4K、8K。")]),a._v(" "),t("p",[a._v("问题？表的大小不应该至少是1MB吗？一个区的大小\n实际上用户启用innodb_file_per_table,创建表的默认大小时96KB，是因为每个段开始时，先用32个页大小的碎片页来存放数据，在使用完这些页后才是64个连续页的申请。这样做的好处是对于一些小标，开始时申请较少的空间，节省磁盘开销。\n用完32个随拍你也后，新的页会采用区的方式进行空间申请，可能一次申请几个区。")]),a._v(" "),t("h4",{attrs:{id:"_4-2-4-页"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-4-页"}},[a._v("#")]),a._v(" 4.2.4 页")]),a._v(" "),t("p",[a._v("页是InnoDB磁盘管理的最小单位。\n常见的页有数据页（B-tree Node）、undo页（undoLog Page）、系统页（System Page）、事务数据页（Transaction system Page）...")]),a._v(" "),t("h4",{attrs:{id:"_4-2-5-行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-5-行"}},[a._v("#")]),a._v(" 4.2.5 行")]),a._v(" "),t("p",[a._v("InnoDB存储引擎是面向行的，数据是按行存放。每个页存放的行记录有硬性定义，最多允许存放16KB/2（即8192行）减去200行=7992行记录")]),a._v(" "),t("h3",{attrs:{id:"_4-3-innodb行记录格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-innodb行记录格式"}},[a._v("#")]),a._v(" 4.3 InnoDB行记录格式")]),a._v(" "),t("p",[a._v("意味着页中保存着一行行的数据\n每个行数据中有两个字节代表next_recorder表示下一个记录的偏移量，InnoDB存储引擎在页内部通过一种链表的结构来串连各个行记录")]),a._v(" "),t("p",[a._v("疑问？Null标志位只有8位，若第10列是null，怎么标志？")]),a._v(" "),t("h4",{attrs:{id:"_4-3-3-行溢出数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-3-行溢出数据"}},[a._v("#")]),a._v(" 4.3.3 行溢出数据")]),a._v(" "),t("p",[a._v("VARCHAR（N）中的N指的是字符的长度\n文档中说明VARCHAR类型最大支持65535，单位是字节。\n还需要注意的是，MySQL官方手册中定义的65535长度是指所有VARCHAR列长度总和，如果列的长度总和超出这个长度，依然无法创建。\n当发生行溢出时，数据存放在页类型为Uncompress BLOB页中。\n每个页中至少应该有两条行记录（否则失去了B+ Tree的意义，变成链表）\n因此，如果页中只能存放一条记录，InnoDB存储引擎会自动将行数据存放到溢出页中。")]),a._v(" "),t("p",[a._v("对于TEXT或BLOB数据，放在数据页中还是BLOB中和VARCHAR一样，取决于是否能保证一个页至少能存放两条记录。")]),a._v(" "),t("h4",{attrs:{id:"_4-3-5-char的行结构存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-5-char的行结构存储"}},[a._v("#")]),a._v(" 4.3.5 CHAR的行结构存储")]),a._v(" "),t("h3",{attrs:{id:"_4-4-innodb数据页结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-innodb数据页结构"}},[a._v("#")]),a._v(" 4.4 InnoDB数据页结构")]),a._v(" "),t("p",[a._v("InnoDB数据页由以下七个部分组成，")]),a._v(" "),t("h2",{attrs:{id:"第五章-索引与算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第五章-索引与算法"}},[a._v("#")]),a._v(" 第五章 索引与算法")]),a._v(" "),t("h3",{attrs:{id:"_5-1-innodb索引概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-innodb索引概述"}},[a._v("#")]),a._v(" 5.1 InnoDB索引概述")]),a._v(" "),t("ul",[t("li",[a._v("B+树索引")]),a._v(" "),t("li",[a._v("全文索引")]),a._v(" "),t("li",[a._v("哈希索引")])]),a._v(" "),t("p",[a._v("B+是找到所在的页，数据库把页读入到内存，再到内存中查找得到数据。\n哈希索引是自适应的，InnoDB会根据表的使用情况自动为表生成哈希索引，不能人为干预？")]),a._v(" "),t("h3",{attrs:{id:"_5-2-数据结构与算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-数据结构与算法"}},[a._v("#")]),a._v(" 5.2 数据结构与算法")]),a._v(" "),t("p",[a._v("Page Directory中的槽？")]),a._v(" "),t("h3",{attrs:{id:"_5-3-b-树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-b-树"}},[a._v("#")]),a._v(" 5.3 B+树")]),a._v(" "),t("h3",{attrs:{id:"_5。4-b-树索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5。4-b-树索引"}},[a._v("#")]),a._v(" 5。4 B+树索引")]),a._v(" "),t("p",[a._v("B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。内部都是B+树，叶子节点存放着所有数据。不同之处在于，叶子节点存放的是否是一整行的信息")]),a._v(" "),t("p",[a._v("聚集索引\nInnoDB存储引擎表是索引组织表？")]),a._v(" "),t("h2",{attrs:{id:"第六章-锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第六章-锁"}},[a._v("#")]),a._v(" 第六章 锁")]),a._v(" "),t("h3",{attrs:{id:"_6-1-lock与latch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-lock与latch"}},[a._v("#")]),a._v(" 6.1 lock与latch")]),a._v(" "),t("p",[a._v("latch一般被称为轻量级锁，InnoDB引擎中可以分为mutex(互斥量)与rwlock（读写锁）作用对象是线程，目的保证并发线程操作临界资源的正确性，无死锁检测。\nlock的对象是事务，锁定数据库对象如表、页、行。\n一般仅在commit或rollback后释放，有死锁机制。")]),a._v(" "),t("h3",{attrs:{id:"_6-2-innodb中的锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-innodb中的锁"}},[a._v("#")]),a._v(" 6.2 InnoDB中的锁")]),a._v(" "),t("h4",{attrs:{id:"共享排他锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#共享排他锁"}},[a._v("#")]),a._v(" 共享排他锁")]),a._v(" "),t("p",[a._v("共享锁（S Lock），允许事务读一行数据\n排他锁（X Lock），允许事务删除或更新一行数据\n排他锁与共享锁的兼容性表格")]),a._v(" "),t("p",[a._v("除此之外，InnoDB存储引擎支持多粒度锁定，一种额外的所方式，称为意向锁。？？？\n意向共享锁（IS Lock）\n意向排他锁（IX Lock）\n特殊：S与IX不兼容")]),a._v(" "),t("h4",{attrs:{id:"事务隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别"}},[a._v("#")]),a._v(" 事务隔离级别")]),a._v(" "),t("p",[a._v("4种\nRead Uncommitted（未提交读）---可能导致脏读、不可重复读、幻读\n最低的隔离级别，允许读取未提交事务的数据。\nRead Committed（提交读）---阻止脏读\n允许读取并发事务已提交的数据。\nRepeatable read（可重复读） --- 阻止脏读和不可重复读\n多次读结果都一样？\nSERIALIZABLE（串行化）\n实现ACID、")])])}),[],!1,null,null,null);t.default=r.exports}}]);